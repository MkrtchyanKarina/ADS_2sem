def build_prefix(s: str) -> list:
    """Префикс-функция для всех непустых префиксов заданной строки s."""
    n = len(s)
    p = [0] * (n + 1)
    i, j = 1, 0
    while i < n:
        if s[i] == s[j]:  # Если символы на позициях совпадают, то можем увеличить длину совпадающего префикса и записать это в массив.
            i += 1
            j += 1
            p[i] = j
        else:
            if j > 0:  # Иначе вернемся к меньшему значению функции и проверим еще раз
                j = p[j]
            else:
                i += 1  # Если нельзя вернуться к меньшему префиксу, то ставим 0
                p[i] = 0
    return p[1:]



if __name__ == "__main__":
    print(build_prefix("aaaAAA"))
    print(build_prefix("abacaba"))

"""
1) Преимущество заключается в том, что к примеру при поиске подстроки в строке и их несовпадении, нам не нужно повторно сравнивать символы, так как у нас посчитаны значения префикс-функции
2) Последовательность шагов:
    Инициализируем массив p длиной n (длина строки), где p[i] будет хранить длину максимального собственного префикса, совпадающего с суффиксом подстроки s[0:i].
    Устанавливаем два указателя:
        i — текущая позиция в строке (начинается с 1).
        j — длина текущего совпадающего префикса (начинается с 0).
        Пока i < n:
            Если символы совпадают (s[i] == s[j]):
                Увеличиваем оба указателя (i += 1, j += 1).
                Записываем p[i] = j.
            Иначе:
                Если j > 0, откатываемся к меньшему значению: j = p[j].
                Иначе (j == 0), записываем p[i] = 0 и двигаем i += 1.
Ключевые переменные:
    i — индекс текущего символа, для которого вычисляем значение.
    j — длина текущего совпадающего префикса/суффикса.
    p — массив значений префикс-функции.
3) Для вычисления префикс-функции для подстрок строки можно использовать скользящее окно или суффиксный массив
4) Алгоритм учитывает различия между буквами в разном регистре, так как в Python "a" != "A"
"""